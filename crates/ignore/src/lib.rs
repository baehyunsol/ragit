use regex::Regex;use std::path::{Path, PathBuf};use std::str::FromStr;use ragit_core::Matcher;use ragit_core_utils::path::get_relative_path;use ragit_fs::{is_dir, is_symlink, read_dir};#[derive(Debug)]pub struct Ignore {    patterns: Vec<Pattern>,    /// Some patterns are stronger than others. For example, you cannot `rag add .ragit/` even with `--force`.    strong_patterns: Vec<Pattern>,}impl Ignore {    pub fn new() -> Self {        Ignore {            patterns: vec![],            strong_patterns: vec![],        }    }    pub fn add_line(&mut self, line: &str) {        if !line.is_empty() && !line.starts_with("#") {            self.patterns.push(Pattern::parse(line));        }    }    pub fn add_strong_pattern(&mut self, pattern: &str) {        self.strong_patterns.push(Pattern::parse(pattern));    }    // like `.gitignore`, `.ragignore` never fails to parse    pub fn parse(s: &str) -> Self {        let mut patterns = vec![];        for line in s.lines() {            let t = line.trim();            if t.is_empty() || t.starts_with("#") {                continue;            }            patterns.push(Pattern::parse(t));        }        Ignore { patterns, strong_patterns: vec![] }    }    /// It returns `Vec<(ignored: bool, file: String)>`. It only returns files, not dirs.    pub fn walk_tree(        &self,        root_dir: &Path,        dir: &Path,        follow_symlink: bool,        skip_ignored_dirs: bool,    ) -> Result<Vec<(bool, String)>, std::io::Error> {        let mut result = vec![];        self.walk_tree_worker(root_dir, dir, &mut result, follow_symlink, skip_ignored_dirs, false)?;        Ok(result)    }    fn walk_tree_worker(        &self,        root_dir: &Path,        file: &Path,        buffer: &mut Vec<(bool, String)>,        follow_symlink: bool,        skip_ignored_dirs: bool,        already_ignored: bool,  // if a file is inside an ignored directory, there's no need to call `is_match` again    ) -> Result<(), std::io::Error> {        if self.is_strong_match(root_dir, file) {            return Ok(());        }        // ragit doesn't track sym links at all        if is_symlink(file.to_str().unwrap()) && !follow_symlink {            return Ok(());        }        let is_match = already_ignored || self.is_match(file);        if is_dir(file.to_str().unwrap()) {            if !skip_ignored_dirs || !is_match {                for entry in read_dir(file.to_str().unwrap(), false)? {                    self.walk_tree_worker(root_dir, &PathBuf::from(entry), buffer, follow_symlink, skip_ignored_dirs, is_match)?;                }            }        }        else {            buffer.push((is_match, file.to_str().unwrap().to_string()));        }        Ok(())    }    /// Some patterns are stronger than others. For example, you cannot `rag add .ragit/` even with `--force`.    pub fn is_strong_match(&self, root_dir: &Path, file: &Path) -> bool {        let Ok(rel_path) = get_relative_path(root_dir, file) else { return false; };        for pattern in self.strong_patterns.iter() {            if pattern.is_match(&rel_path) {                return true;            }        }        false    }}impl Matcher for Ignore {    fn is_match(&self, path: &Path) -> bool {        for pattern in self.patterns.iter() {            if pattern.is_match(path) {                return true;            }            }        false    }}#[derive(Clone, Debug)]pub struct Pattern(Vec<PatternUnit>);impl Pattern {    pub fn parse(pattern: &str) -> Self {        let mut pattern = pattern.to_string();        // `a/b` -> `**/a/b`        // `/a/b` -> `a/b`        if !pattern.starts_with("/") {            pattern = format!("**/{}", pattern);        }        else {            pattern = pattern.get(1..).unwrap().to_string();        }        // I'm not sure about this...        if pattern.ends_with("/") {            pattern = pattern.get(0..(pattern.len() - 1)).unwrap().to_string();        }        let mut result = pattern.split("/").map(|p| p.parse::<PatternUnit>().unwrap_or_else(|_| PatternUnit::Fixed(p.to_string()))).collect::<Vec<_>>();        match result.last() {            Some(PatternUnit::DoubleAster) => {},            _ => {                // `target` must match `crates/ignore/target/debug`                result.push(PatternUnit::DoubleAster);            },        }        Pattern(result)    }}impl Matcher for Pattern {    // `path` must be a normalized, relative path    fn is_match(&self, path: &Path) -> bool {        let mut path_str = path.to_str().unwrap().to_string();        // there's no reason to treat `a/b` and `a/b/` differently        if path_str.len() > 1 && path_str.ends_with("/") {            path_str = path_str.get(0..(path_str.len() - 1)).unwrap().to_string();        }        match_worker(            self.0.clone(),            path_str.split("/").map(|p| p.to_string()).collect::<Vec<_>>(),        )    }}fn match_worker(pattern: Vec<PatternUnit>, path: Vec<String>) -> bool {    // (0, 0) means it's looking at pattern[0] and path[0].    // if it reaches (pattern.len(), path.len()), it matches    let mut cursors = vec![(0, 0)];    while let Some((pattern_cursor, path_cursor)) = cursors.pop() {        if pattern_cursor == pattern.len() && path_cursor == path.len() {            return true;        }        if pattern_cursor >= pattern.len() || path_cursor >= path.len() {            if let Some(PatternUnit::DoubleAster) = pattern.get(pattern_cursor) {                if !cursors.contains(&(pattern_cursor + 1, path_cursor)) {                    cursors.push((pattern_cursor + 1, path_cursor));                }            }            continue;        }        if match_dir(&pattern[pattern_cursor], &path[path_cursor]) {            if let PatternUnit::DoubleAster = &pattern[pattern_cursor] {                if !cursors.contains(&(pattern_cursor, path_cursor + 1)) {                    cursors.push((pattern_cursor, path_cursor + 1));                }                if !cursors.contains(&(pattern_cursor + 1, path_cursor)) {                    cursors.push((pattern_cursor + 1, path_cursor));                }            }            if !cursors.contains(&(pattern_cursor + 1, path_cursor + 1)) {                cursors.push((pattern_cursor + 1, path_cursor + 1));            }        }    }    false}fn match_dir(pattern: &PatternUnit, path: &str) -> bool {    match pattern {        PatternUnit::DoubleAster => true,        PatternUnit::Regex(r) => r.is_match(path),        PatternUnit::Fixed(p) => path == p,    }}#[derive(Clone, Debug)]pub enum PatternUnit {    DoubleAster,    // **    Regex(Regex),   // a*    Fixed(String),  // a}impl FromStr for PatternUnit {    type Err = regex::Error;    fn from_str(s: &str) -> Result<Self, regex::Error> {        if s == "**" {            Ok(PatternUnit::DoubleAster)        }        else if s.contains("*") || s.contains("?") || s.contains("[") {            let s = s                .replace(".", "\\.")                .replace("+", "\\+")                .replace("(", "\\")                .replace(")", "\\")                .replace("{", "\\{")                .replace("}", "\\}")                .replace("*", ".*")                .replace("?", ".");            Ok(PatternUnit::Regex(Regex::new(&format!("^{s}$"))?))        }        else {            Ok(PatternUnit::Fixed(s.to_string()))        }    }}